<html>
<head>
  <title>A Visual Git Reference</title>
  <style type='text/css'>
    .center {text-align: center;}
    .other-link {font-style: italic;}
    .other-link-png {display: none;}
    ol > ol {list-style-type: lower-alpha;}
  </style>
</head>
<body>
  <h1 id="top">A Visual Git Reference</h1>

  <p class="other-link other-link-svg">If your browser supports it, the <a
    href="index-svg.html">SVG</a> version of this page might look better.</p>

  <p class="other-link other-link-png">If the images do not work, try the <a
    href="index.html">Non-SVG</a> version of this page.</p>

  <p>This page gives brief, visual reference for the most common commands
  in git.  Once you know a bit about how git works, this site may solidify
  your understanding.  If you're interested in how this site was created, see
  my <a href='http://github.com/MarkLodato/visual-git-guide'>GitHub
    repository</a>.</p>

  <h2 id="contents">Contents</h2>
  <ol>
    <li><a href="#basic-usage">Basic Usage</a></li>
    <li><a href="#conventions">Conventions</a></li>
    <li><a href="#commands-in-detail">Commands in Detail</a></li>
    <ol>
      <li><a href="#diff">Diff</a></li>
      <li><a href="#commit">Commit</a></li>
      <li><a href="#checkout">Checkout</a></li>
      <li><a href="#detached">Committing with a Detached HEAD</a></li>
      <li><a href="#reset">Reset</a></li>
      <li><a href="#merge">Merge</a></li>
    </ol>
    <li><a href="#technical-notes">Technical Notes</a></li>
  </ol>

  <h2 id="basic-usage">Basic Usage</h2>

  <div class="center"><img src='basic-usage.png'></div>

  <p>The four commands above copy files between the working directory, the
  stage (also called the index), and the history (in the form of commits).</p>

  <ul>

    <li><tt>git add <em>files</em></tt> copies <em>files</em> (at their
    current state) to the stage.</li>

    <li><tt>git commit</tt> saves a snapshot of the stage as a commit.</li>

    <li><tt>git reset -- <em>files</em></tt> unstages files; that is, it copies
    <em>files</em> from the latest commit to the stage.  Use this command to
    "undo" a <tt>git add <em>files</em></tt>.  You can also <tt>git reset</tt>
    to unstage everything.</li>

    <li><tt>git checkout -- <em>files</em></tt> copies files from the stage to
    the working directory.  Use this to throw away local changes.</li>

  </ul>

  <p>You can use <tt>git reset -p</tt>, <tt>git checkout -p</tt>, or <tt>git
    add -p</tt> instead of (or in addition to) specifying particular files to
  interactively choose which hunks copy.</p>

  <h2 id="conventions">Conventions</h2>

  <p>In the rest of this document, we will use graphs of the following
  form.</p>

  <div class="center"><img src='conventions.png'></div>

  <p>Commits are shown in green as 5-character IDs, and they point to their
  parents.  Branches are shown in orange, and they point to particular
  commits.  The current branch is identified by the special reference
  <em>HEAD</em>, which is "attached" to that branch.  In this image, the five
  latest commits are shown, with <em>ed489</em> being the most recent.
  <em>master</em> (the current branch) points to this commit, while
  <em>maint</em> (another branch) points to an ancestor of <em>master</em>'s
  commit.</p>

  <h2 id="commands-in-detail">Commands in Detail</h2>

  <h3 id="diff">Diff</h3>

  <p>There are various ways to look at differences between commits.  Below are
  some common examples.  Any of these commands can optionally take extra
  filename arguments that limit the differences to the named files.</p>

  <div class="center"><img src='diff.png'></div>

  <h3 id="commit">Commit</h3>

  <p>When you commit, git creates a new commit object using the files from the
  stage and sets the parent to the current commit.  It then points the current
  branch to this new commit.  In the image below, the current branch is
  <em>master</em>.   Before the command was run, <em>master</em> pointed to
  <em>ed489</em>.  Afterward, a new commit, <em>f0cec</em>, was created, with
  parent <em>ed489</em>, and then <em>master</em> was moved to the new
  commit.</p>

  <div class="center"><img src='commit-master.png'></div>

  <p>This same process happens even when the current branch is an ancestor of
  another.  Below, a commit occurs on branch <em>maint</em>, which was an
  ancestor of <em>master</em>, resulting in <em>1800b</em>.  Afterward,
  <em>maint</em> is no longer an ancestor of <em>master</em>.  To join the two
  histories, a <a href='#merge'>merge</a> (or rebase) will be necessary.</p>

  <div class="center"><img src='commit-maint.png'></div>

  <p>Sometimes a mistake is made in a commit, but this is easy to correct with
  <tt>git commit --amend</tt>.  When you use this command, git creates a new
  commit with the same parent as the current commit.  (The old commit will be
  discarded if nothing else references it.)</p>

  <div class="center"><img src='commit-amend.png'></div>

  <p>A fourth case is committing with a <a href="#detached">detached
    HEAD</a>, as explained later.</p>

  <h3 id="checkout">Checkout</h3>

  <p>The checkout command is used to copy files from the history (or stage) to
  the working directory, and to optionally switch branches.</p>

  <p>When a filename (and/or <tt>-p</tt>) is given, git copies those files
  from the given commit to the stage and the working directory.  For example,
  <tt>git checkout HEAD~ foo.c</tt> copies the file <tt>foo.c</tt> from the
  commit called <em>HEAD~</em> (the parent of the current commit) to the
  working directory, and also stages it.  (If no commit name is given, files
  are copied from the stage.)  Note that the current branch is not
  changed.</p>

  <div class="center"><img src='checkout-files.png'></div>

  <p>When a filename is <em>not</em> given but the reference is a (local)
  branch, <em>HEAD</em> is moved to that branch (that is, we "switch to" that
  branch), and then the stage and working directory are set to match the
  contents of that commit.  Any file that exists in the new commit
  (<em>a47c3</em> below) is copied; any file that exists in the old commit
  (<em>ed489</em>) but not in the new one is deleted; and any file that exists
  in neither is ignored.</p>

  <div class="center"><img src='checkout-branch.png'></div>

  <p>When a filename is <em>not</em> given and the reference is <em>not</em>
  a (local) branch &mdash; say, it is a tag, a remote branch, a SHA-1 ID, or
  something like <em>master~3</em> &mdash; we get an anonymous branch, called
  a <em>detached HEAD</em>.  This is useful for jumping around the history.
  Say you want to compile verison 1.6.6.1 of git.  You can <tt>git checkout
    v1.6.6.1</tt> (which is a tag, not a branch), compile, install, and then
  switch back to another branch, say <tt>git checkout master</tt>.  However,
  committing works slightly differently with a detached HEAD; this is covered
  <a href="#detached">below</a>.</p>

  <div class="center"><img src='checkout-detached.png'></div>

  <h3 id="detached">Committing with a Detached HEAD</h3>

  <p>When <em>HEAD</em> is detached, commits work like normal, except no named
  branch gets updated.  (You can think of this as an anonymous branch.)</p>

  <div class="center"><img src='commit-detached.png'></div>

  <p>Once you check out something else, say <em>master</em>, the commit is
  (presumably) no longer referenced by anything else, and gets lost.  Note
  that after the command, there is nothing referencing <em>2eecb</em>.</p>

  <div class="center"><img src='checkout-after-detached.png'></div>

  <p>If, on the other hand, you want to save this state, you can create a new
  named branch using <tt>git checkout -b <em>name</em></tt>.</p>

  <div class="center"><img src='checkout-b-detached.png'></div>

  <h3 id="reset">Reset</h3>

  <p>The reset command moves the current branch to another position, and
  optionally updates the stage and the working directory.  It also is used to
  copy files from the history to the stage without touching the working
  directory.</p>

  <p>If a commit is given with no filenames, the current branch is moved to
  that commit, and then the stage is updated to match this commit.  If
  <tt>--hard</tt> is given, the working directory is also updated.  If
  <tt>--soft</tt> is given, neither is updated.</p>

  <div class="center"><img src='reset-commit.png'></div>

  <p>If a commit is not given, it defaults to <em>HEAD</em>.  In this case,
  the branch is not moved, but the stage (and optionally the working
  directory, if <tt>--hard</tt> is given) are reset to the contents of the
  last commit.</p>

  <div class="center"><img src='reset.png'></div>

  <p>If a filename (and/or <tt>-p</tt>) is given, then the command works
  similarly to <a href='#checkout'>checkout</a> with a filename, except only
  the stage (and not the working directory) is updated.  (You may also specify
  the commit from which to take files, rather than <em>HEAD</em>.)</p>

  <div class="center"><img src='reset-files.png'></div>

  <h3 id="merge">Merge</h3>

  <p>A merge creates a new commit that incorporates changes from other
  commits.  Before merging, the stage must match the current commit.  The
  trivial case is if the other commit is an ancestor of the current commit, in
  which case nothing is done.  The next most simple is if the current commit
  is an ancestor of the other commit.  This results in a <em>fast-forward</em>
  merge.  The reference is simply moved, and then the new commit is checked
  out.</p>

  <div class="center"><img src='merge-ff.png'></div>

  <p>Otherwise, a "real" merge must occur.  You can choose other strategies,
  but the default is to perform a "recursive" merge, which basically takes the
  current commit (<em>ed489</em> below), the other commit (<em>33104</em>),
  and their common ancestor (<em>b325c</em>), and performs a <a
    href='http://en.wikipedia.org/wiki/Three-way_merge'>three-way merge</a>.
  The result is saved to the working directory and the stage, and then a
  commit occurs, with an extra parent for the other commit
  (<em>33104</em>).</p>

  <div class="center"><img src='merge.png'></div>

  <h2 id="technical-notes">Technical Notes</h2>

  <p>The contents of files are not actually stored in the index
  (<em>.git/index</em>) or in commit objects.  Rather, each file is stored in
  the object database (<em>.git/objects</em>) as a <em>blob</em>, identified
  by its SHA-1 hash.  The index file lists the filenames along with the
  identifier of the associated blob, as well as some other data.  For commits,
  there is an additional data type, a <em>tree</em>, also identified by its
  hash.  Trees correspond to directories in the working directory, and contain
  a list of trees and blobs corresponding to each filename within that
  directory.  Each commit stores the identifier of its top-level tree, which
  in turn contains all of the blobs and other trees associated with that
  commit.</p>

  <p>If you make a commit using a detached HEAD, the last commit really is
  referenced by something: the reflog for HEAD.  However, this will expire
  after a while, so the commit will eventually be garbage collected, similar
  to commits discarded with <tt>git commit --amend</tt> or <tt>git
    rebase</tt>.</p>

  <hr>
  <p>Copyright &copy; 2010, <a href='mailto:lodatom@gmail.com'>Mark
    Lodato</a>.  This work is licensed under a <a rel="license"
    href="http://creativecommons.org/licenses/by-nc-sa/3.0/us/">Creative
    Commons Attribution-Noncommercial-Share Alike 3.0 United States
    License</a>.</p>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-13167645-1");
pageTracker._trackPageview();
} catch(err) {}</script>
</body>
</html>
